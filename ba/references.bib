@inbook{Ehrig2001,
  author    = {Ehrig, Hartmut
               and Mahr, Bernd
               and Gro{\ss}e-Rhode, Martin
               and Cornlius, Felix
               and Zeitz, Philip},
  title     = {Mathematisch-strukturelle Grundlagen der Informatik},
  booktitle = {Mathematisch-strukturelle Grundlagen der Informatik},
  year      = {2001},
  chapter   = {{\"A}quivalenzrelationen},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {93--107},
  abstract  = {{\"A}quivalenzrelationen sind ein sehr m{\"a}chtiges Hilfsmittel f{\"u}r Klassifikation und Abstraktion in der Mathematik und speziell der mathematischen Informatik. Dies zeigt sich vor allem in dem Begriff der {\"A}quivalenzklassen, den wir in Abschnitt 5.4 einf{\"u}hren. Zuvor behandeln wir im Anschlu{\ss} an die konzeptuelle Einleitung zun{\"a}chst die zentrale Definition der {\"A}quivalenzrelation selbst und die Konstruktion der Abschlu{\ss}bildung. Dahinter verbirgt sich die minimale Erg{\"a}nzung einer beliebigen Relation zu einer {\"A}quivalenzrelation, die diese enth{\"a}lt. Da{\ss} dies immer eindeutig moglich ist, ist ein wichtiges Ergebnis.},
  isbn      = {978-3-642-56792-6},
  doi       = {10.1007/978-3-642-56792-6_6},
  url       = {https://doi.org/10.1007/978-3-642-56792-6_6}
}

@article{2021-egg,
  author     = {Willsey, Max and Nandi, Chandrakana and Wang, Yisu Remy and Flatt, Oliver and Tatlock, Zachary and Panchekha, Pavel},
  title      = {egg: Fast and Extensible Equality Saturation},
  year       = {2021},
  issue_date = {January 2021},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {5},
  number     = {POPL},
  url        = {https://doi.org/10.1145/3434304},
  doi        = {10.1145/3434304},
  abstract   = {An e-graph efficiently represents a congruence relation over many expressions. Although they were originally developed in the late 1970s for use in automated theorem provers, a more recent technique known as equality saturation repurposes e-graphs to implement state-of-the-art, rewrite-driven compiler optimizations and program synthesizers. However, e-graphs remain unspecialized for this newer use case. Equality saturation workloads exhibit distinct characteristics and often require ad-hoc e-graph extensions to incorporate transformations beyond purely syntactic rewrites.  This work contributes two techniques that make e-graphs fast and extensible, specializing them to equality saturation. A new amortized invariant restoration technique called rebuilding takes advantage of equality saturation's distinct workload, providing asymptotic speedups over current techniques in practice. A general mechanism called e-class analyses integrates domain-specific analyses into the e-graph, reducing the need for ad hoc manipulation.  We implemented these techniques in a new open-source library called egg. Our case studies on three previously published applications of equality saturation highlight how egg's performance and flexibility enable state-of-the-art results across diverse domains.},
  journal    = {Proc. ACM Program. Lang.},
  month      = jan,
  articleno  = {23},
  numpages   = {29},
  keywords   = {equality saturation, e-graphs}
}

@article{2023-egglog,
  author     = {Zhang, Yihong and Wang, Yisu Remy and Flatt, Oliver and Cao, David and Zucker, Philip and Rosenthal, Eli and Tatlock, Zachary and Willsey, Max},
  title      = {Better Together: Unifying Datalog and Equality Saturation},
  year       = {2023},
  issue_date = {June 2023},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {7},
  number     = {PLDI},
  url        = {https://doi.org/10.1145/3591239},
  doi        = {10.1145/3591239},
  abstract   = {We present egglog, a fixpoint reasoning system that unifies Datalog and equality saturation (EqSat). Like Datalog, egglog supports efficient incremental execution, cooperating analyses, and lattice-based reasoning. Like EqSat, egglog supports term rewriting, efficient congruence closure, and extraction of optimized terms. We identify two recent applications -- a unification-based pointer analysis in Datalog and an EqSat-based floating-point term rewriter -- that have been hampered by features missing from Datalog but found in EqSat or vice-versa. We evaluate our system by reimplementing those projects in egglog. The resulting systems in egglog are faster, simpler, and fix bugs found in the original systems.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {jun},
  articleno  = {125},
  numpages   = {25},
  keywords   = {Datalog, Program optimization, Rewrite systems, Equality saturation}
}

@inproceedings{phaseorder-2009,
  author    = {Tate, Ross and Stepp, Michael and Tatlock, Zachary and Lerner, Sorin},
  title     = {Equality saturation: a new approach to optimization},
  year      = {2009},
  isbn      = {9781605583792},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1480881.1480915},
  doi       = {10.1145/1480881.1480915},
  abstract  = {Optimizations in a traditional compiler are applied sequentially, with each optimization destructively modifying the program to produce a transformed program that is then passed to the next optimization. We present a new approach for structuring the optimization phase of a compiler. In our approach, optimizations take the form of equality analyses that add equality information to a common intermediate representation. The optimizer works by repeatedly applying these analyses to infer equivalences between program fragments, thus saturating the intermediate representation with equalities. Once saturated, the intermediate representation encodes multiple optimized versions of the input program. At this point, a profitability heuristic picks the final optimized program from the various programs represented in the saturated representation. Our proposed way of structuring optimizers has a variety of benefits over previous approaches: our approach obviates the need to worry about optimization ordering, enables the use of a global optimization heuristic that selects among fully optimized programs, and can be used to perform translation validation, even on compilers other than our own. We present our approach, formalize it, and describe our choice of intermediate representation. We also present experimental results showing that our approach is practical in terms of time and space overhead, is effective at discovering intricate optimization opportunities, and is effective at performing translation validation for a realistic optimizer.},
  booktitle = {Proceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {264–276},
  numpages  = {13},
  keywords  = {intermediate representation, equality reasoning, compiler optimization},
  location  = {Savannah, GA, USA},
  series    = {POPL '09}
}

@book{ullman2008,
  author    = {Ullman, Jeffrey D. and Lam, Monica S. and Sethi, Ravi and Aho, Alfred V.},
  title     = {{Compiler  Prinzipien, Techniken und Werkzeuge}},
  abstract  = {{Compiler Grunds\"atze, Techniken und Werkzeuge: das "Drachenbuch" von Aho, Sethi und Ullman gilt als das unumstrittene Referenzbuch des Compilerbaus. Das Autorenteam, verst\"arkt durch die weltber\"uhmte Informatikerin Monica Lam, hat das Standardwerk in einer zweiten Auflage komplett \"uberarbeitet ver\"offentlicht. Es bietet eine in allen Aspekten detaillierte Einf\"uhrung in die Theorie und Praxis des Compilerbaus. Das Buch stellt, beginnend mit der Beschreibung der Grammatik einfacher Sprachen, die Grundideen vor, die hinter der Compiler-Technologie stehen und vertieft dann im zweiten Teil die vorgestellten Techniken. Die Autoren behandeln wichtige Themen wie die lexikalische Analyse, die Syntaxanalyse, Typ\"uberpr\"ufung, Zwischencodegenerierung, Codeoptimierung und Softwaredesign. Neu hinzugef\"ugt wurden vier Kapitel, die sich mit der Laufzeitumgebung sowie den Besonderheiten moderner Prozessorarchitektur besch\"aftigen. Dieses geballte Wissen wird in Praxisbeispielen effizient zusammengef\"uhrt. Dabei wird die Verwendung der Werkzeuge wie lex und yacc in Beispielen demonstriert. Das urspr\"ungliche Drachenbuch st\"utzte sich auf die Werkzeuge lex und yacc, um Compiler in der Programmiersprache C zu entwickeln. Um den heutigen Anspr\"uchen gerecht zu werden, beinhaltet die Neuauflage das \"Ubersichtskapitel 2, zusammen mit Anhang A, deshalb ein komplett in Java entwickeltes Compiler Front-End. Da die restlichen Kapitel (insbesondere Kapitel 3, 4 und 5) immer noch auf lex und yacc aufbauen, wurde in der deutschen \"Ubersetzung der Anhang C hinzugef\"ugt. Dieser stellt das Werkzeug SableCC vor, mit dem Lexer und Parser in Java erstellt werden k\"onnen. Vorgestellt wird auch, wie man mit SableCC abstrakte Syntaxb\"aume generieren und Analysephasen implementieren kann. Der Anhang C sowie die CWS-Webseite zu diesem Buch enthalten zus\"atzliche \"Ubungen. Diese Erg\"anzungen erm\"oglichen den Einsatz dieses Buches sowohl f\"ur die Lehre, basierend auf Java, als auch die praktische Anwendung des Wissens f\"ur Informatiker, die in Java entwickeln. Wahrlich ein "Drachenbuch" Dieses Buch richtet sich an Studierende und Praktiker aus der Informatik und an alle, die effizienten Code entwickeln wollen. Begleitend zum Buch dazu gibt es L\"osungsans\"atze zu den Aufgaben und alle Abbildungen aus dem Buch als Foliensatz. Inhalt Struktur eines Compilers Evolution der Programmiersprachen Wissenschaft des Compilerbaus Anwendungen der Compilertechnologie Grundlagen von Programmiersprachen Ein einfacher syntaxgerichteter \"Ubersetzer Lexikalische Analyse (neu) Syntaktische Analyse Syntaxgerichtete \"Ubersetzung Zwischencodeerzeugung Laufzeitumgebungen (neu) Codeerzeugung Maschinenunabh\"angige Optimierungen Optimierungen f\"ur Parallelit\"at und Lokalit\"at (neu) Interprozedurale Analyse (neu) Hier finden Sie Downloads zu diesem Titel.}},
  pages     = {1296},
  publisher = {Pearson Deutschland},
  year      = {2008},
  isbn      = {9783827370976},
  doi       = {},
  url       = {https://elibrary.pearson.de/book/99.150005/9783863265748},
  keywords  = {Code},
  keywords  = {Compiler},
  keywords  = {Programmiersprache},
  keywords  = {Drachenbuch},
  keywords  = {Übersetzer}
}

@misc{cole,
  author = {Cole Kurashige},
  title  = {The e-graph data structure},
  url    = {https://www.cole-k.com/2023/07/24/e-graphs-primer/},
  note   = {besucht am 05.02.2025}
}

@misc{cranelift,
  author = {Bytecode Alliance, NPO},
  title  = {Cranelift},
  url    = {https://cranelift.dev/},
  note   = {besucht am 23.11.2024}
}

@misc{bootstrap,
  author = {Mark Otto and others},
  title  = {Bootstrap 5.3.3},
  url    = {https://getbootstrap.com/},
  note   = {besucht am 11.12.2024}
}

@misc{graphviz,
  author = {Ellson, John and Gansner, Emden and Hu, Yifan and North, Stephen and others},
  title  = {Graphviz},
  url    = {https://graphviz.org/},
  note   = {besucht am 08.01.2025}
}

@misc{d3-graphviz,
  author = {Magnus Jacobsson},
  title  = {d3-graphviz},
  url    = {https://github.com/magjac/d3-graphviz},
  note   = {besucht am 08.01.2025}
}

@misc{fastapi,
  author = {Sebastián Ramírez},
  title  = {FastAPI},
  url    = {https://fastapi.tiangolo.com/},
  note   = {besucht am 11.12.2024}
}

@misc{devito,
  author = {Zachary DeVito},
  title  = {Intro to EGraphs},
  url    = {https://colab.research.google.com/drive/1tNOQijJqe5tw-Pk9iqd6HHb2abC5aRid?usp=sharing},
  note   = {besucht am 26.11.2024}
}